# Gesture Handling

Этот код представляет собой элегантное решение для работы с жестами в iOS с использованием Combine. 

## Основные компоненты системы

### 1. **GestureType**
Определяет различные типы жестов:
- Tap (нажатие)
- Swipe (свайп)
- LongPress (долгое нажатие)
- Pan (перетаскивание)
- Pinch (масштабирование)
- Edge (краевой свайп)

Каждый тип содержит соответствующий распознаватель жестов (UIGestureRecognizer).

### 2. **GestureItem**
Обёртка для:
- Распознавателя жестов (`recognizer`)
- Типа жеста (`gestureType`)

### 3. **GesturePublisher**
Реализует протокол `Publisher` из Combine для публикации событий жестов.

### 4. **GestureSubscription**
Управляет подпиской на события жестов и их обработкой.

### 5. **Gesture**
Основной класс, предоставляющий удобный интерфейс для работы с жестами:
- Добавление обработчиков
- Настройка распознавателей жестов
- Управление зависимостями между жестами

### 6. **Расширения UIView**
Добавляет удобные методы для создания жестов прямо на UIView.

## Как это работает

1. Создаётся жест через методы расширения UIView (`tap()`, `swipe()` и т.д.)
2. Жест добавляется к UIView через `addGestureRecognizer`
3. Создаётся цепочка Combine для обработки событий
4. При срабатывании жеста событие публикуется через Publisher
5. Подписчики получают событие и выполняют обработку

## Примеры использования

### 1. Простое нажатие (Tap)

```swift
let view = UIView()

view.tap()
    .numberOfTapsRequired(2) // Двойное нажатие
    .addHandler { _ in
        print("Двойное нажатие распознано!")
    }
```

### 2. Долгое нажатие с настройкой

```swift
view.longPress()
    .minimumPressDuration(1.5) // Минимальная длительность 1.5 секунды
    .addHandler { _ in
        print("Долгое нажатие распознано")
    }
```

### 3. Свайп с фильтрацией по направлению

```swift
view.swipe()
    .direction(.left) // Только свайп влево
    .addHandler { _ in
        print("Свайп влево распознан")
    }
```

### 4. Комбинирование жестов

```swift
let tapGesture = view.tap()
let longPressGesture = view.longPress()

// Нажатие сработает только если не было долгого нажатия
tapGesture.require(toFail: longPressGesture)
    .addHandler { _ in
        print("Простое нажатие")
    }

longPressGesture.addHandler { _ in
    print("Долгое нажатие")
}
```

### 5. Использование с Combine

```swift
view.pan()
    .publisher
    .filter { $0.recognizer.state == .changed }
    .sink { item in
        let translation = item.recognizer.translation(in: view)
        print("Перемещение: \(translation)")
    }
    .store(in: &cancellables)
```

## Преимущества этого подхода

1. **Типобезопасность** - Каждый жест имеет свой тип, что предотвращает ошибки
2. **Гибкость** - Легко комбинировать жесты и добавлять фильтры
3. **Интеграция с Combine** - Можно использовать всю мощь реактивного программирования
4. **Читаемость** - Цепочки вызовов делают код более понятным
5. **Расширяемость** - Легко добавить новые типы жестов

## Когда использовать

1. **Сложные взаимодействия** - Когда нужно обрабатывать комбинации жестов
2. **Реактивные интерфейсы** - В связке с Combine для реактивного UI
3. **Кастомные контролы** - При создании собственных UI компонентов
4. **Игровые интерфейсы** - Где важна точная обработка жестов
5. **Анимации** - Для плавных интерактивных анимаций

Этот код предоставляет мощный и элегантный способ работы с жестами, который значительно упрощает реализацию сложных интерактивных интерфейсов в iOS-приложениях.
